import org.apache.tools.ant.filters.ReplaceTokens

plugins {
    alias(libs.plugins.java.library)
    alias(libs.plugins.shadow)
}

description = 'Shaded version of Apache Tika 4.0 snapshot with core, standard parsers, scientific parser, and OCR parser'

dependencies {
    implementation(libs.tika.core)
    implementation(libs.tika.parsers.standard)
    // Extended parsers for better content extraction
    implementation(libs.tika.parser.scientific)
    // OCR support for images and scanned documents (requires tesseract)
    implementation(libs.tika.parser.ocr)
}

// Task to collect and merge all service files from dependencies
tasks.register('collectServiceFiles') {
    def outputDir = layout.buildDirectory.dir('service-files')
    outputs.dir(outputDir)

    // Get the resolved files at configuration time (compatible with config cache)
    def classpathFiles = configurations.runtimeClasspath.incoming.files

    doLast {
        def servicesDir = outputDir.get().asFile
        servicesDir.deleteDir()
        servicesDir.mkdirs()

        def serviceFiles = [:]

        // Iterate through all runtime classpath JARs
        classpathFiles.each { jar ->
            if (jar.name.endsWith('.jar')) {
                try {
                    def zipFile = new java.util.zip.ZipFile(jar)
                    zipFile.entries().each { entry ->
                        if (entry.name.startsWith('META-INF/services/') && !entry.isDirectory()) {
                            def serviceName = entry.name.replace('META-INF/services/', '')
                            if (!serviceFiles.containsKey(serviceName)) {
                                serviceFiles[serviceName] = new LinkedHashSet()
                            }

                            // Read the service file contents
                            def content = zipFile.getInputStream(entry).text
                            content.split('\n').each { line ->
                                def trimmed = line.trim()
                                if (trimmed && !trimmed.startsWith('#')) {
                                    serviceFiles[serviceName].add(trimmed)
                                }
                            }
                        }
                    }
                    zipFile.close()
                } catch (Exception e) {
                    logger.warn("Failed to process JAR: ${jar.name}: ${e.message}")
                }
            }
        }

        // Write the merged service files with relocated package names
        serviceFiles.each {
            serviceName, implementations ->
            // Relocate the service file name (for org.apache.tika services)
            def relocatedServiceName = serviceName.replace('org.apache.tika.', 'ai.pipestream.shaded.tika.')

            def serviceFile = new File(servicesDir, "META-INF/services/${relocatedServiceName}")
            serviceFile.parentFile.mkdirs()

            // Relocate the implementation class names
            def relocatedImplementations = implementations.collect {
                impl ->
                impl.replace('org.apache.tika.', 'ai.pipestream.shaded.tika.')
            }

            serviceFile.text = """#  Licensed to the Apache Software Foundation (ASF) under one or more
#  contributor license agreements.  See the NOTICE file distributed with
#  this work for additional information regarding copyright ownership.
#  The ASF licenses this file to You under the Apache License, Version 2.0
#  (the "License"); you may not use this file except in compliance with
#  the License.  You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

${relocatedImplementations.join('\n')}
"""
            logger.lifecycle("Created service file ${relocatedServiceName} with ${relocatedImplementations.size()} implementations")
        }
    }
}

tasks {
    shadowJar {
        archiveClassifier.set('')

        // Depend on the service file collection task
        dependsOn collectServiceFiles

        // Include the merged and pre-relocated service files from our custom task
        from(layout.buildDirectory.dir('service-files')) {
            include 'META-INF/services/**'
        }

        // Exclude original service files from dependencies - we'll use our merged and pre-relocated ones
        exclude 'META-INF/services/org.apache.tika.*'

        // Append other important resource files that need merging
        append 'META-INF/DEPENDENCIES'
        append 'META-INF/NOTICE'
        append 'META-INF/NOTICE.txt'
        append 'META-INF/LICENSE'
        append 'META-INF/LICENSE.txt'

        // Handle duplicate entries by excluding them
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        // Exclude signature files that commonly cause ZIP conflicts
        exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
        // Exclude maven metadata that causes duplicates
        exclude 'META-INF/maven/**/pom.properties'
        exclude 'META-INF/maven/**/pom.xml'

        // Allow large ZIP entries if needed
        zip64 true

        // Relocate packages to avoid conflicts
        // relocate 'org.apache.tika', 'ai.pipestream.shaded.tika'
        // relocate 'com.google.protobuf', 'ai.pipestream.shaded.protobuf'
        // relocate 'com.google.common', 'ai.pipestream.shaded.guava'

        // Preserve important manifest entries
        manifest {
            attributes(
                'Implementation-Title': 'Tika 4 Shaded',
                'Implementation-Version': project.version,
                'Implementation-Vendor': 'ai.pipestream',
                'Built-By': System.getProperty('user.name'),
                'Built-JDK': System.getProperty('java.version'),
                'Created-By': "Gradle ${gradle.gradleVersion}"
            )
        }
    }

    build {
        dependsOn shadowJar
    }
}

// Enable resource filtering to replace @version@ in application.properties
processResources {
    filesMatching('**/*.properties') {
        filter(ReplaceTokens, tokens: [
                version: project.version.toString()
        ])
    }
}

// Disable default java artifacts publishing
components.java.withVariantsFromConfiguration(configurations.apiElements) { skip() }
components.java.withVariantsFromConfiguration(configurations.runtimeElements) { skip() }

publishing {
    publications {
        maven(MavenPublication) {
            // Use the shadowJar task as the main artifact
            artifact tasks.shadowJar
            
            // The parent build.gradle adds sources and javadoc jars from components.java
            // But since we skipped variants, they might not be added?
            // components.java adds the variants. If we skip them, we get nothing from it?
            // Sources and Javadoc are usually separate variants.
            // Let's ensure sources and javadoc are present.
            artifact tasks.sourcesJar
            artifact tasks.javadocJar

            pom {
                name = 'Tika 4 Shaded'
                description = 'Shaded version of Apache Tika 4.0 snapshot'
            }
        }
    }
}
